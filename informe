INFORME PRÁCTICA 4 - ALGORITMOS

Pablo Chantada Saborido (pablo.chantada@udc.es)
Aldana Smyna Medina Lostaunau (aldana.medina@udc.es)

----------------------------------------------------------------------------------------------------------------------------------------------

INTRODUCCIÓN
En esta práctica, se implementará el algoritmo de Dijkstra y se verificará su correcto funcionamiento, ademas de estudiar la eficiencia temporal de la creación de montículos a partir de vectores de n tamaño que ira aumentando con una progresión geométrica de razón 2, desde n = 16 hasta n = 1024. 

En este informe, presentaremos una descripción detallada de la implementación de dicho algoritmo y su complejidad computacional para el calculo de distancias minimas en grafos completos no dirigidos con pesos aleatorios entre 1 y 1000.

Para garantizar valores precisos, usaremos un umbral de confianza de 1.000.000 ns. Ejecutando 1000 veces el algoritmo y haciendo la 
media de los tiempos resultantes en todos los casos que no superen dicho umbral. Para representarlo en la tabla se indicará con un (*) al lado del tiempo.

Para las mediciones utilizaremos un ordenador de mesa con las siguientes características: 
- Sistema Operativo: Windows 10 Home, 54 bits
- Procesador: Intel(R) Core(TM) i5-10400F CPU @ 2.90GHz   2.90 GHz, 6 core
- RAM: 16 Gb
- Python 3.12.0

Por último, TODOS LOS VALORES UTILIZADOS EN EL INFORME ESTARÁN EN NANOSEGUNDOS (ns).


---------- EJERCICIO 1 y 2 ----------
Implementamos en PYTHON el algoritmo de Dijkstra utilizando como base el pseudocódigo que nos indican en la práctica y comprobamos que funcionan correctamente creando



+-------+---------------------+-----------------+---------------+-----------------+
|   n   |      t(n) (ns)      | t(n) / (n**2.9) | t(n) / (n**3) | t(n) / (n**3.1) |
+-------+---------------------+-----------------+---------------+-----------------+
| 16    |    2251900.000000   |    725.439420   |   549.780273  |    416.655534   |
| 32    |   17107600.000000   |    738.336180   |   522.082520  |    369.168090   |
| 64    |   150355800.000000  |    869.357212   |   573.561859  |    378.409705   |
| 128   |  1122875500.000000  |    869.806591   |   535.428762  |    329.595065   |
| 256   |  8844103600.000000  |    917.820855   |   527.149653  |    302.767970   |
| 512   |  80688810900.000000 |   1121.838728   |   601.178489  |    322.163575   |
| 1024  | 624087574200.000000 |   1162.453693   |   581.226846  |    290.613423   |
+-------+---------------------+-----------------+---------------+-----------------+

indicar con t(n)/n lo q tiende x no con la O

TABLAS

Importante:

-indicar la cota subestimada que se estudia
-indicar la cota sobrestimada que se estudia
-Se resaltan los tiempos medidos en bucles indicando las iteraciones empleadas. (en esta practica no hay)
NOTA: los datos con (*) son tiempos medios de 1000 ejecuciones del algoritmo ya que no consiguieron superar el umbral 
de confianza. 
-Se indica la constante a la que tiene la sucesión de la cota ajustada.
-Mediciones anómalas en las tres cotas no solo en la constante

CONCLUSIONES??


Como es el rendimiento del algoritmo

Xq va lento

-Evaluar cómo diferentes implementaciones afectan el rendimiento. (¿Cambiar el lenguaje de programación, la biblioteca utilizada o la estructura de datos impacta significativamente en el rendimiento?)


-Identificar posibles puntos de estrangulamiento. ¿Existen partes específicas del código que son más costosas en términos de tiempo de ejecución?
